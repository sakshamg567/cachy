This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
cmd/
  cache-node/
    main.go
  server/
    main.go
internal/
  cache/
    lru.go
    node.go
  coordinator/
    coordinator.go
    hashRing.go
shared/
  proto/
    cacheNodepb/
      cache-node_grpc.pb.go
      cache-node.pb.go
    cache-node.proto
util/
  hash.go
go.mod
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cmd/cache-node/main.go">
package main

import (
	"flag"
	"fmt"
	"log"
	"net"

	"github.com/sakshamg567/cachy/internal/cache"
	"github.com/sakshamg567/cachy/shared/proto/cacheNodepb"
	"google.golang.org/grpc"
)

func main() {
	port := flag.String("port", "50051", "port to run cache node on")
	flag.Parse()

	lis, err := net.Listen("tcp", fmt.Sprintf(":%s", *port))
	if err != nil {
		log.Fatalf("failed to listen : %v", err)
	}

	grpcServer := grpc.NewServer()
	node := cache.NewCacheNode(100)
	cacheNodepb.RegisterCacheServer(grpcServer, node)
	log.Printf("cache node running on port %s", *port)
	log.Fatal(grpcServer.Serve(lis))
}
</file>

<file path="cmd/server/main.go">
package main

import (
	"encoding/json"
	"log"
	"net/http"

	"github.com/sakshamg567/cachy/internal/coordinator"
)

func main() {
	addresses := []string{"localhost:50051", "localhost:50052", "localhost:50053"}

	cd := coordinator.NewCoordinator(addresses)

	http.HandleFunc("/get", func(w http.ResponseWriter, r *http.Request) {
		key := r.URL.Query().Get("key")
		val, err := cd.Get(r.Context(), key)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		json.NewEncoder(w).Encode(map[string]string{"value": val})
	})

	http.HandleFunc("/set", func(w http.ResponseWriter, r *http.Request) {
		var body struct {
			Key   string `json:"key"`
			Value string `json:"value"`
		}
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}

		ok := cd.Set(r.Context(), body.Key, body.Value)
		if !ok {
			http.Error(w, "failed to set", http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusOK)
	})

	log.Fatal(http.ListenAndServe(":6969", nil))
}
</file>

<file path="internal/cache/lru.go">
package cache

import (
	"errors"
	"sync"
)

type dllNode struct {
	key   string
	value string
	next  *dllNode
	prev  *dllNode
}

type DLL struct {
	front *dllNode
	back  *dllNode
}

func (d *DLL) moveToFront(node *dllNode) {
	if d.front == node {
		return
	}

	if node.prev != nil {
		node.prev.next = node.next
	}
	if node.next != nil {
		node.next.prev = node.prev
	}
	if d.back == node {
		d.back = node.prev
	}

	node.prev = nil
	node.next = d.front
	if d.front != nil {
		d.front.prev = node
	}
	d.front = node
	if d.back == nil {
		d.back = d.front
	}
}

func (d *DLL) evictLRU() *dllNode {
	if d.back == nil {
		return nil
	}
	node := d.back
	if node.prev != nil {
		node.prev.next = nil
	}
	d.back = node.prev
	if d.back == nil {
		d.front = nil
	}
	return node
}

type KEY string

type LruCache struct {
	capacity int
	cache    map[KEY]*dllNode
	dll      *DLL
	mu       sync.RWMutex
}

func NewLruCache(cap int) *LruCache {
	return &LruCache{
		capacity: cap,
		cache:    map[KEY]*dllNode{},
		dll:      &DLL{},
	}
}

const (
	ERRKEYNOTFOUND = "key not found"
)

func (c *LruCache) get(key KEY) (string, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()
	if node, ok := c.cache[key]; ok {
		c.dll.moveToFront(node)
		return node.value, nil
	}
	return "", errors.New(ERRKEYNOTFOUND)
}

func (c *LruCache) set(key KEY, value string) bool {
	c.mu.RLock()
	defer c.mu.RUnlock()
	if node, ok := c.cache[key]; ok {
		node.value = value
		c.dll.moveToFront(node)
		return true
	}
	if len(c.cache) >= c.capacity {
		evicted := c.dll.evictLRU()
		if evicted != nil {
			delete(c.cache, KEY(evicted.key))
		}
	}

	newNode := &dllNode{
		key:   string(key),
		value: value,
	}
	c.dll.moveToFront(newNode)
	c.cache[key] = newNode
	return true
}
</file>

<file path="internal/cache/node.go">
package cache

import (
	"context"

	cachepb "github.com/sakshamg567/cachy/shared/proto/cacheNodepb"
)

type CacheNode struct {
	cachepb.UnimplementedCacheServer
	lru *LruCache
}

func NewCacheNode(cap int) cachepb.CacheServer {
	return &CacheNode{
		lru: &LruCache{
			capacity: cap,
		},
	}
}

func (cn *CacheNode) Get(ctx context.Context, req *cachepb.GetRequest) (*cachepb.GetResponse, error) {
	val, err := cn.lru.get(KEY(req.Key))
	if err != nil {
		return &cachepb.GetResponse{Found: false}, nil
	}

	return &cachepb.GetResponse{Value: val, Found: true}, nil
}

func (cn *CacheNode) Set(ctx context.Context, req *cachepb.SetRequest) (*cachepb.SetResponse, error) {
	_ = cn.lru.set(KEY(req.Key), req.Value)

	return &cachepb.SetResponse{Success: true}, nil
}
</file>

<file path="internal/coordinator/coordinator.go">
package coordinator

import (
	"context"

	"github.com/sakshamg567/cachy/shared/proto/cacheNodepb"
)

type Coordinator struct {
	ring *HashRing
}

func NewCoordinator(addresses []string) *Coordinator {

	ring := NewHashRing(addresses)

	return &Coordinator{
		ring: ring,
	}
}

func (c *Coordinator) Get(ctx context.Context, key string) (string, error) {

	n := c.ring.getNode(key)

	val, err := n.Get(ctx, &cacheNodepb.GetRequest{Key: key})
	if err != nil {
		return "", err
	}

	return val.Value, nil
}

func (c *Coordinator) Set(ctx context.Context, key, value string) bool {
	n := c.ring.getNode(key)

	_, err := n.Set(ctx, &cacheNodepb.SetRequest{Key: key, Value: value})
	if err != nil {
		return false
	}

	return true
}
</file>

<file path="internal/coordinator/hashRing.go">
package coordinator

import (
	"sort"

	"github.com/sakshamg567/cachy/shared/proto/cacheNodepb"
	"github.com/sakshamg567/cachy/util"
	"google.golang.org/grpc"
)

type HashRing struct {
	nodes map[uint32]cacheNodepb.CacheClient
	keys  []uint32
}

func NewHashRing(addresses []string) *HashRing {
	n := make(map[uint32]cacheNodepb.CacheClient)
	var keys []uint32

	for _, addr := range addresses {
		h := util.Hash(addr)
		conn, err := grpc.Dial(addr, grpc.WithInsecure())
		if err != nil {
			panic(err)
		}
		client := cacheNodepb.NewCacheClient(conn)
		n[h] = client
		keys = append(keys, h)
	}

	sort.Slice(keys, func(i, j int) bool {
		return keys[i] < keys[j]
	})
	return &HashRing{
		nodes: n,
		keys:  keys,
	}
}

// func (r *HashRing) AddNode(node *CacheNode) {
// 	h := hash(node.ip)
// 	r.nodes[h] = node
// 	r.keys = append(r.keys, h)
// 	sort.Slice(r.keys, func(i, j int) bool {
// 		return r.keys[i] < r.keys[j]
// 	})
// }

func (r *HashRing) getNode(key string) cacheNodepb.CacheClient {
	h := util.Hash(key)

	idx := sort.Search(len(r.keys), func(i int) bool {
		return r.keys[i] >= h
	})

	if idx == len(r.keys) {
		idx = 0
	}

	return r.nodes[r.keys[idx]]
}
</file>

<file path="shared/proto/cacheNodepb/cache-node_grpc.pb.go">
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: shared/proto/cache-node.proto

package cacheNodepb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Cache_Get_FullMethodName = "/cache.Cache/Get"
	Cache_Set_FullMethodName = "/cache.Cache/Set"
)

// CacheClient is the client API for Cache service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CacheClient interface {
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error)
}

type cacheClient struct {
	cc grpc.ClientConnInterface
}

func NewCacheClient(cc grpc.ClientConnInterface) CacheClient {
	return &cacheClient{cc}
}

func (c *cacheClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, Cache_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheClient) Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetResponse)
	err := c.cc.Invoke(ctx, Cache_Set_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CacheServer is the server API for Cache service.
// All implementations must embed UnimplementedCacheServer
// for forward compatibility.
type CacheServer interface {
	Get(context.Context, *GetRequest) (*GetResponse, error)
	Set(context.Context, *SetRequest) (*SetResponse, error)
	mustEmbedUnimplementedCacheServer()
}

// UnimplementedCacheServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCacheServer struct{}

func (UnimplementedCacheServer) Get(context.Context, *GetRequest) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedCacheServer) Set(context.Context, *SetRequest) (*SetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedCacheServer) mustEmbedUnimplementedCacheServer() {}
func (UnimplementedCacheServer) testEmbeddedByValue()               {}

// UnsafeCacheServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CacheServer will
// result in compilation errors.
type UnsafeCacheServer interface {
	mustEmbedUnimplementedCacheServer()
}

func RegisterCacheServer(s grpc.ServiceRegistrar, srv CacheServer) {
	// If the following call pancis, it indicates UnimplementedCacheServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Cache_ServiceDesc, srv)
}

func _Cache_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cache_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cache_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cache_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServer).Set(ctx, req.(*SetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Cache_ServiceDesc is the grpc.ServiceDesc for Cache service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Cache_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cache.Cache",
	HandlerType: (*CacheServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Cache_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _Cache_Set_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "shared/proto/cache-node.proto",
}
</file>

<file path="shared/proto/cacheNodepb/cache-node.pb.go">
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v3.21.12
// source: shared/proto/cache-node.proto

package cacheNodepb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type GetRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRequest) Reset() {
	*x = GetRequest{}
	mi := &file_shared_proto_cache_node_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRequest) ProtoMessage() {}

func (x *GetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_shared_proto_cache_node_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRequest.ProtoReflect.Descriptor instead.
func (*GetRequest) Descriptor() ([]byte, []int) {
	return file_shared_proto_cache_node_proto_rawDescGZIP(), []int{0}
}

func (x *GetRequest) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

type GetResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         string                 `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Found         bool                   `protobuf:"varint,2,opt,name=found,proto3" json:"found,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetResponse) Reset() {
	*x = GetResponse{}
	mi := &file_shared_proto_cache_node_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetResponse) ProtoMessage() {}

func (x *GetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_shared_proto_cache_node_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetResponse.ProtoReflect.Descriptor instead.
func (*GetResponse) Descriptor() ([]byte, []int) {
	return file_shared_proto_cache_node_proto_rawDescGZIP(), []int{1}
}

func (x *GetResponse) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *GetResponse) GetFound() bool {
	if x != nil {
		return x.Found
	}
	return false
}

type SetRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetRequest) Reset() {
	*x = SetRequest{}
	mi := &file_shared_proto_cache_node_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetRequest) ProtoMessage() {}

func (x *SetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_shared_proto_cache_node_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetRequest.ProtoReflect.Descriptor instead.
func (*SetRequest) Descriptor() ([]byte, []int) {
	return file_shared_proto_cache_node_proto_rawDescGZIP(), []int{2}
}

func (x *SetRequest) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *SetRequest) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type SetResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetResponse) Reset() {
	*x = SetResponse{}
	mi := &file_shared_proto_cache_node_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetResponse) ProtoMessage() {}

func (x *SetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_shared_proto_cache_node_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetResponse.ProtoReflect.Descriptor instead.
func (*SetResponse) Descriptor() ([]byte, []int) {
	return file_shared_proto_cache_node_proto_rawDescGZIP(), []int{3}
}

func (x *SetResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

var File_shared_proto_cache_node_proto protoreflect.FileDescriptor

const file_shared_proto_cache_node_proto_rawDesc = "" +
	"\n" +
	"\x1dshared/proto/cache-node.proto\x12\x05cache\"\x1e\n" +
	"\n" +
	"GetRequest\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\"9\n" +
	"\vGetResponse\x12\x14\n" +
	"\x05value\x18\x01 \x01(\tR\x05value\x12\x14\n" +
	"\x05found\x18\x02 \x01(\bR\x05found\"4\n" +
	"\n" +
	"SetRequest\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\"'\n" +
	"\vSetResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess2c\n" +
	"\x05Cache\x12,\n" +
	"\x03Get\x12\x11.cache.GetRequest\x1a\x12.cache.GetResponse\x12,\n" +
	"\x03Set\x12\x11.cache.SetRequest\x1a\x12.cache.SetResponseB\x1aZ\x18shared/proto/cacheNodepbb\x06proto3"

var (
	file_shared_proto_cache_node_proto_rawDescOnce sync.Once
	file_shared_proto_cache_node_proto_rawDescData []byte
)

func file_shared_proto_cache_node_proto_rawDescGZIP() []byte {
	file_shared_proto_cache_node_proto_rawDescOnce.Do(func() {
		file_shared_proto_cache_node_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_shared_proto_cache_node_proto_rawDesc), len(file_shared_proto_cache_node_proto_rawDesc)))
	})
	return file_shared_proto_cache_node_proto_rawDescData
}

var file_shared_proto_cache_node_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_shared_proto_cache_node_proto_goTypes = []any{
	(*GetRequest)(nil),  // 0: cache.GetRequest
	(*GetResponse)(nil), // 1: cache.GetResponse
	(*SetRequest)(nil),  // 2: cache.SetRequest
	(*SetResponse)(nil), // 3: cache.SetResponse
}
var file_shared_proto_cache_node_proto_depIdxs = []int32{
	0, // 0: cache.Cache.Get:input_type -> cache.GetRequest
	2, // 1: cache.Cache.Set:input_type -> cache.SetRequest
	1, // 2: cache.Cache.Get:output_type -> cache.GetResponse
	3, // 3: cache.Cache.Set:output_type -> cache.SetResponse
	2, // [2:4] is the sub-list for method output_type
	0, // [0:2] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_shared_proto_cache_node_proto_init() }
func file_shared_proto_cache_node_proto_init() {
	if File_shared_proto_cache_node_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_shared_proto_cache_node_proto_rawDesc), len(file_shared_proto_cache_node_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_shared_proto_cache_node_proto_goTypes,
		DependencyIndexes: file_shared_proto_cache_node_proto_depIdxs,
		MessageInfos:      file_shared_proto_cache_node_proto_msgTypes,
	}.Build()
	File_shared_proto_cache_node_proto = out.File
	file_shared_proto_cache_node_proto_goTypes = nil
	file_shared_proto_cache_node_proto_depIdxs = nil
}
</file>

<file path="shared/proto/cache-node.proto">
syntax = "proto3";

package cache;

option go_package = "shared/proto/cacheNodepb";

service Cache {
   rpc Get(GetRequest) returns (GetResponse);
   rpc Set(SetRequest) returns (SetResponse);
}

message GetRequest {
   string key = 1;  
}

message GetResponse {
   string value = 1;
   bool found = 2;
}

message SetRequest {
   string key = 1;
   string value = 2;
}

message SetResponse {
   bool success = 1;
}
</file>

<file path="util/hash.go">
package util

import (
	"hash/fnv"
)

func Hash(id string) uint32 {
	h := fnv.New32a()
	h.Write([]byte(id))
	return h.Sum32()
}
</file>

<file path="go.mod">
module github.com/sakshamg567/cachy

go 1.24.1

require (
	golang.org/x/net v0.41.0 // indirect
	golang.org/x/sys v0.33.0 // indirect
	golang.org/x/text v0.26.0 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20250707201910-8d1bb00bc6a7 // indirect
	google.golang.org/grpc v1.75.1 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
)
</file>

</files>
